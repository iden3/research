% % !TEX root =/Users/martabellesmunoz/Dropbox/Documents/Berkley-Standards/Structure.tex

\documentclass[11pt]{article}
\usepackage[colorlinks=true,
			urlcolor=black,
			linkcolor=black,
			citecolor=black
			]{hyperref}

\input{preamble.tex}

\makeatletter
\renewcommand\AB@affilsepx{, \protect\Affilfont}
\makeatother

\title{ Sparse Merkle Trees \vspace{-0.2cm} }
\author[1]{Jordi Baylina}
\author[1,2]{Marta Bellés}
\affil[1]{iden3}
\affil[2]{Universitat Pompeu Fabra}
\date{} %% if you don't need date to appear
\setcounter{Maxaffil}{0}
\renewcommand\Affilfont{\itshape\small}

\begin{document}

\maketitle 
\vspace{1cm}
\tableofcontents

\vspace{0.5cm}

%\newpage

\newpage
\section{Scope}
A Merkle tree or hash tree is an authenticated data structure where every leaf node of the tree contains the cryptographic hash of a data block and every non leaf node contains the concatenated hashes of its child nodes \cite{compact}. If the majority of the leaves are empty, then they are called sparse Merkle trees \cite{security-mt}. This proposal aims to standardize the generation of this second kind of binary trees.


\section{Motivation}
Merkle trees allow to link a set of data to a unique has value, which is very optimal and useful, specially in blockchain technology, as it provides a secure and efficient verification of large data sets by storing only a little piece of data on-chain. 
% 
For instance, they can be used to verify any kind of data stored, handled and transferred in and between computers. They can help ensure that data blocks received from other peers in a peer-to-peer network are received undamaged and unaltered, and even to check that the other peers do not lie and send fake blocks \cite{wikipediansdata}. 


\section{Background}
{\it We are still working on the literature compending the state of the art of this area.} %\cite{efficient-merkle}.

%
%{\it Work in progress.}%
%Merkle trees basically en el que cada nodo que no es una hoja está etiquetado con el hash de la concatenación de las etiquetas o valores (para nodos hoja) de sus nodos hijo.
%that allow the parent node is the hash of its children, and the leaf nodes are hashes of the original data blocks. A hash tree or Merkle tree is a tree in which every leaf node is labelled with the hash of a data block and every non-leaf node is labelled with the cryptographic hash of the labels of its child nodes [REF]. % 

%%We actually deal with Sparse Merkle Trees, but we will refer to them simply as Merkle Trees [REF].\\
%
%This way, only a little piece of data is stored on-chain. And with only this piece of data we can check/validate (with negligible error probability) if a certain piece of data is stored in the tree (or not). 
%De esta forma proporciona un método de verificación segura y eficiente de los contenidos de grandes estructuras de datos. En sus aplicaciones prácticas normalmente el hash del nodo raíz va firmado para asegurar su integridad y que la verificación sea totalmente fiable. La demostración de que un nodo hoja es parte de un árbol hash dado requiere una cantidad de datos proporcional al logaritmo del número de nodos del árbol.
%Hash trees can be used to verify any kind of data stored, handled and transferred in and between computers. They can help ensure that data blocks received from other peers in a peer-to-peer network are received undamaged and unaltered, and even to check that the other peers do not lie and send fake blocks [REF]. proving something is or not in the tree. Merkle trees stuff.

% We store (key, values) from people in what so called Merkle trees. This allows us to ... .
%
%The following pages / This document contains the specifications of the Merkle trees implementation used in iden3 and how to generate and verify the proofs. We also add a section explaining per sobre les possibles concerns i blabla. \\

%	
%\section{Background}				\input{background}
%%	A section introducing the problem, including definitions, references to previous work and other background details.
%
%Problem: storage of big data structures. Store as minimum information as possible. Reference to previous work and other background details? \\
%
%Definition of (sparse) {\bf Merkle tree}: each node consists of a pair (key, value). Our Merkle trees are binary trees % i.e. at most 2 leaves.
%whose nodes consist of pairs {\bf key-value} $(k,v)$. Explain what is a pair key-value. We use them to store claims, which are kept in the leafs and the rest of the nodes furthering up are the hashes of their children. 
%Trees have at most 140 levels, that is, a maximum of $2^140$ claims can be stored in them. This number is determined by the length of the hash function used, we will explain later why).\\



	
\section{Terminology}				% \input{terminology}
%	For consistency across documents, adopt throughout the proposal, terminology and definitions used in the ZKProof proceedings, with pointers to the relevant sections.

The following concepts are definitions and properties we assume across the document.

\begin{itemize}
	\item The leaves of the {\it Merkle tree} consist of key-value pairs $(k,v)$. We distinguish three different nodes:
	\begin{itemize}
		\item {\it Empty node}: A vertex that stores the key and value zero.
		\item {\it Leaf}: A vertex with both empty children. %Claims are stored in this kind of nodes. 
		%	It contains the claim {\color{blue}{i com guarda el key-value (la info que es vol guardar), amb el 1 aquell}}.
		\item {\it Internal node}: A vertex with at least one non-empty child. The value is and the key such. It has the hash of its children. % If it has one empty child, it keeps the hash of the non-empty one. 
	\end{itemize}
	\item A {\it Merkle audit path} for a leaf in a Merkle tree is the shortest list of additional nodes in the tree required to compute the root hash for that tree.
	\item If the root computed from the audit path matches the true root, then the audit path is a  {\it proof of membership} for that leaf in the tree.
	\item Otherwise, it is a {\it proof of non-membership} for that leaf in the tree. 
\end{itemize}

%Proofs: %(definition of a proof The siblings stuff!!:):

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{images/MT-pfs-h.png} 
	%	  \includegraphics[scale=0.8]{MT-pfs.png} 
	% https://www.lucidchart.com/documents/!
\end{figure}

%Two types of proves, when there is an empty node or when there is a different node. 

% and then the nodes further up in the tree 
% Every time a new claim is added to the tree, it is kept in one leaf of the tree and the rest of the nodes 
% furthering up contain the hashes of their children. 
%composed of vertices of $key-value$
% that store the data in their leafs and Nodes further up in the tree are the hashes of their respective children. % All the nodes consist of a pair key-value. 

%
%\begin{itemize}
%	\item Proof of membership
%	\item Proof of non-membership
%	\begin{itemize}
%		\item Case 1: empty node
%		\item Case 2: different node
%	\end{itemize}
%\end{itemize}

\section{Challenges}				%\input{challenges} 
%	For motivating the discussions, highlight the main challenges in creating such a standard, as well as any open or unresolved questions.

{\it Work in progress}.

%Improve such and such.
%
%We included that hash(0,0)=0.
%
%Com que no anem fins avall de tot, p.m.


% This section is not in the supposed structure of the doc.	
\section{Description}				%\input{description}

Let $e=(k,v)$ be a new entry in a tree $T$. The node in which this piece of data $e$ is stored in $T$ is uniquely determined from the data itself. Let $H$ be a secure hash function returning an array of bits \footnote{If the hash function $H$ does not return a binary number, binarize it later.}. The leaf in which $e$ should be stored in $T$ is defined by 
$$H_{path} = H(e) = H(1 || k || v).$$ 
This array of bits is going to represent a path through the tree: starting by the less significant bit and from the root of $T$, it descents the tree by taking the left edge if there is a 0 and right one if there is a 1.\\ %{\it (TODO: Add an example)} 
%As an example, the leaf corresponding to a hash "01001" in the following tree is:

When adding an entry $e$, we may not (see Sec. \ref{sec-security}) go down to the last level of the tree (by last we mean looking at all the bits, length of which depends on the hash function $H$). What we do instead, is go down through the path until we find a node without siblings (a leaf). 
%
If the leaf is empty, we store $e$. Otherwise, that node stores some other $e'$ (as non-empty leafs store claims) with $H(e') = H'_{path}$. This means that $H_{path}$ and $H'_{path}$ start with the same sequence of bits. 
%
We compare both hashes and go down the tree until the first different bit. 
these two values and find the first different bit (included). 
Then we store $e$ and $e'$ in their corresponding leafs of the path.\\
%

{\underline{Example}}\\ 

As an example, consider $e$ such that $H_{path}=0111111...$ and the Merkle tree below where in each leaf there is represented the value (and not the key) of each stored piece of data:
%
%Consider the tree from figure [REF]. In the figure, we have depicted/represented in each vertex last bytes of the key in hexadecimal (big endian).

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/ex-MT-5.png}
\end{figure}
If we go down the tree following the sequence 01111111... we get to the leaf containing the value 0704eaec of some $e'$ with $H'_{path}=0111110...$ . Comparing $H_{path}$ and $H'_{path}$, the 7th bit is the first different bit. This means, that we should go down to the 7th level and store there the entries as shown in next figure:

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/ex-MT-6.png}
\end{figure}

Note that $e$ is stored in the right (as the 7th bit is a 1) and $e'$ is stored in the left (as it is a 0). Also note that the rest of siblings are empty nodes and how the root and intermediate nodes have changed.\\


{\underline{Remark}}\\

Each node is of the form $(H[b, k, v])$, where $b = 1$ if terminal node (leaf) and $b = 0$ otherwise. More precisely,
\begin{itemize} 
	\item Each leaf consists of a pair ($H(1 || k || v)$, $k||v$).
	\item Each intermediate node of a pair ($H(H_L||H_R)$, $K_L||K_R$), where $(H_L,K_L)$ is the key-value of its left child and $(H_L,K_L)$ the key-value of its right child.
\end{itemize}
%$
%
%we indicate We store $e$ as: $(k,v)$ with $k = $. The rest of nodes furthering up consist of $adf$: 

\underline{Pseudocode}\\

The procedure to store an entry in a Merkle tree is described below in pseudocode. 

\begin{algorithm}
	\begin{algorithmic}[1]
		\setstretch{1.2}
		\Procedure{Insert Entry $e$ in Merkle Tree $T$ with Root $r$}{}
		%
		\State $H_{path} \gets \text{GetPath($e$)}$
		\State $b \gets \text{LeastSignificantBit($H_{Index}$)}$
		%
		\If {$r$ is empty} $r \gets e$
		\Else
		\While{$r$ is internal vertex} 
		\If {$b=0$} {$r \gets \text{LeftChild($r$)}$}
		%		\EndIf
		\Else { $r \gets \text{RightChild($r$)}$} %\If{$b=1$} (alternatively)
		\EndIf
		\If {$r$ is empty}
		\State $r \gets e$
		\State $H_{Index} \gets H_{Index}\backslash{b}$
		\State $b \gets \text{LeastSignificantBit($H_{Index}$)}$
		\EndIf	
		\EndWhile
		\EndIf
		%
		\State $e' \gets \text{GetEntryStoredIn($r$)}$
		\State $H'_{path} \gets \text{GetPath($e'$)}$
		\If {$H_{path} \not= H'_{path}$}
		\State Find first bit $b_j$ such that $H_{path}(j) \not= H'_{path}(j)$
		\State Leaf($b_0...b_j$)$\gets e$ %Store $e$ in Position$(b_0...b_j)$
		\State Leaf($b_0...b'_j$)$\gets e'$ %Store $e'$ in Position$(b_0...b'_j)$
		\State RecalculateIntermediateNodeValues($T$)	
		\EndIf
		\EndProcedure
	\end{algorithmic}
\end{algorithm}


%
%
%\input{implementation/example}


%the claims in the leafs resulting of the path up to that bit (included). 
%
%What we do is that we 
% go down the tree with both claims until the first different bit and 

%%
%This process of storing an entry $e$ in a tree $T$ with root $r$ is explained in the following pseudocode (code?).\\
%, this is the way to store a new entry $e$ in a tree $T$ with root $r$.\\
% We continue 
% and the first node without siblings, is our position. If there is a coincidence, osigui, si on hem d'anar hi ha algun node, hem de mirar la seva $H_pos$ i esplitar fins el primer número que no coincideixi. 
%until we find a node without siblings. There, we store 
%
%In order of lsb: $k_i = 0$ -> left, and 1 -> right. An *EXAMPLE* of a hash that would determine the position. Actually, only the necessary amount of bits! :) 
%
%So, in our tree there will be three types of vertices: 
% Explicar com va: hi ha tres tipus de nodes --> Buit, etc.
%
%In our case, these data will be claim that will consist in an array of 4 ... : $[e0, e1, e2, e3]$ and we will do $this and that for$ $H_pos$ i tal. So, Hpos is a set of bits that will represent a path through the tree.\\
%
% The information will be stored in leaves of the tree. \\
%
%, except for the leaves (although implicitly, they do). 
% A hash tree is a tree of hashes in which the leaves are hashes of data blocks in, for instance, a file or set of files.  For example, in the picture hash 0 is the result of hashing the concatenation of hash 0-0 and hash 0-1. That is, hash 0 = hash( hash 0-0 || hash 0-1 ) where || denotes concatenation. 


%$$ ESCRIURE-AQUi-UN-LOOP. $$
% Arbre, l'entrada és un key value $(k,v)\in F^2$. ( p is a prime of 256 bits)

%

\newpage
{\it We are working on 4 more procedures}: On one side, DELETE of entries and UPDATE of the tree. On the other side, the generation of MEMBERSHIP proofs and generation of NON-MEMBERSHIP proofs. \\

These last two procedure, although {\it we are working on explaining them in detail in the following delivery}, they have already been implemented in GoLang and JavaScript in the following two repositories:
\begin{itemize}
	\item \url{https://github.com/iden3/go-iden3/blob/master/merkletree/}
	\item \url{https://github.com/iden3/iden3js/tree/master/src/sparse-merkle-tree}
\end{itemize}

 

%\subsection{DELETE of entries}% in the tree}
%%+ EXAMPLE.
%
%\subsection{UPDATE the tree}% in the tree}
%%+ EXAMPLE.
%%\subsection{Procedures}


%Once it is saved, then we take then we construct the leaves up the following way: el tema dels hashos, que es concatena tal i que si hi ha un zero, doncs que llavors només el hash del fill no buit. Then, the rest of intermediate nodes need to be recalculated (as they are hashes of changed children). \\
%
%Note depth is not fixed (at the beginning, it keeps changing). Limit de l'arbre -> tants nivells com números retorna el hash (with is MiMC7, for now). \\
%The position of the (k,v) is determined by ... .
%\begin{enumerate}
%	\item First storage: we "create" a root
%	\item Then: ...
%	\item If (k,v) and k1,v1 , k2 and k1 coincide (collision resistant), but some values do so: lsb thing... .
%\end{enumerate}

% Note that the height of the tree is not fixed from the beginning. It varies when we add stuff. Nevertheless, as MiMC returns a 256-bit string, the trees are bounded to 256 levels. (REMARK that a collision of 256 has negligible probability).
% A partir de quan hi ha col·lisions?


% For a proof, give the necessary siblings. If there is no sibling --> we give a 0 back.
%+ EXAMPLE.


%\subsection{Generate MEMEMBERSHIP proof}
%\subsection{Generate NON-MEMEMBERSHIP proof}

%\newpage
%\subsection{Example}
%\begin{figure}[h]
%	\centering
%	\includegraphics[scale=0.6]{images/ex-MT-5.png} 
%	%	  \includegraphics[scale=0.8]{MT-pfs.png} 
%	% https://www.lucidchart.com/documents/!
%\end{figure}
%\begin{figure}[h]
%	\centering
%	\includegraphics[scale=0.6]{images/ex-MT-6.png} 
%	%	  \includegraphics[scale=0.8]{MT-pfs.png} 
%	% https://www.lucidchart.com/documents/!
%\end{figure}
%%Given a blabla. 

%In both repositories, the entries of the Merkle trees consists of claims and the hash function used is 

%The first value $H_{pos}$ converted to binary (spec) determinates the position in which the value is stored. The second hash $H_{tot}$ is the key associated to $v$ that will be stored together with $v$.


\section{Security}					%\input{security}
\label{sec-security}
The  security  of  an  audit  path  reduces  to  the  collision  resistance  of the underlying hash function. For a proof, see \cite[Lemma 1]{security-mt}. 

%	If relevant, provide a proof of security in the description.
%
%
%Afegir aquí que no pot lie (perquè se li requereix l'altre hash i tal). Examples if one lies.
%
%QUE FALTA CALCULAR LA PROBABILITAT DE COL·LISIÓ.
%
%+ Make sure we go all the tree down to a leaf (that extra 1).
%
%Suppose the queries know the info (the claim).
%
%We do not delete stuff.
%


\section{Implementation}			%\input{implementation}
The standarisation of Merkle trees we proposed are described an implemented in GoLang and JavaScript by the iden3 team in the following repositories:
\begin{itemize}
	\item \url{https://github.com/iden3/go-iden3}
	\item \url{https://github.com/iden3/iden3js}
\end{itemize}

Some detailed examples are also provided in these repositories:
\begin{itemize}
	\item\url{https://github.com/iden3/go-iden3/blob/master/merkletreeDoc/merkletree.md}
	\item\url{https://github.com/iden3/iden3js/tree/master/examples}
\end{itemize}

%
%Such implementation in GoLang and in JavaScript. \\
%
%The entries are pairs key-value.\\
%
%Example from iden3 documentation.
%	\subsection{Hash}				\input{implementation/mimc7}
%	\subsection{Example}			\input{implementation/example}	
	
\section {Intellectual Property}	\input{intellectual-property}
We will release the final version of this proposal under creative commons, to ensure it is freely available to everyone.

%\newpage
\addcontentsline{toc}{section}{References}
\bibliographystyle{acm}
\bibliography{lit}

\end{document}