% % !TEX root =/Users/martabellesmunoz/Dropbox/Documents/Berkley-Standards/Structure.tex

\documentclass[11pt]{article}
\usepackage[colorlinks=true,
			urlcolor=black,
			linkcolor=black,
			citecolor=black
			]{hyperref} 

\input{preamble.tex}

\title{ Sparse Merkle Trees \vspace{-0.2cm} }
\author[1]{Author 1}
\author[2]{Author 2}
\author[1]{Author 3}
\affil[1]{Affiliation 1}
\affil[2]{Affiliation 2}
\date{} %% if you don't need date to appear
\setcounter{Maxaffil}{0}
\renewcommand\Affilfont{\itshape\small}
% \includegraphics[scale=0.3]{iden3.png} 

\begin{document}

\maketitle 
\vspace{1cm}
\tableofcontents

\vspace{0.5cm}

%\newpage

\section{Scope}						%\input{scope}
%	A section specifying the scope of the standard, highlighting what is being standardized and what is not.
\red{What is the scope here?}

	
\section{Motivation}				%\input{motivation}
%	A section describing at least one concrete application motivating the proposed standard, including an explanation of why the community will benefit from such a standard.

Merkle trees or hash trees are %rooted trees % acyclic connected graphs 
rooted graphs that allow large data be linked by a unique hash value, the hash of the root. Moreover,  a unique set of keys produce a deterministic root hash, regardless of the order in which keys have
been inserted or removed (this is called history independence) [REF].\\

Merkle trees basically en el que cada nodo que no es una hoja está etiquetado con el hash de la concatenación de las etiquetas o valores (para nodos hoja) de sus nodos hijo.
that allow the parent node is the hash of its children, and the leaf nodes are hashes of the original data blocks. A hash tree or Merkle tree is a tree in which every leaf node is labelled with the hash of a data block and every non-leaf node is labelled with the cryptographic hash of the labels of its child nodes [REF]. % A {\bf hash tree} or a {\bf Merkle tree} is an authenticated data structure where every leaf node of the tree contains the cryptographic hash of a data block and every non leaf node contains the concatenated hashes of its child nodes. 
If the *majority* [MORE FORMAL?] of the leaves are empty, then we talk about {\bf sparse Merkle trees}. We actually deal with Sparse Merkle Trees, but we will refer to them simply as Merkle Trees [REF].\\

This way, only a little piece of data is stored on-chain. And with only this piece of data we can check/validate (with negligible error probability) if a certain piece of data is stored in the tree (or not). 
De esta forma proporciona un método de verificación segura y eficiente de los contenidos de grandes estructuras de datos. En sus aplicaciones prácticas normalmente el hash del nodo raíz va firmado para asegurar su integridad y que la verificación sea totalmente fiable. La demostración de que un nodo hoja es parte de un árbol hash dado requiere una cantidad de datos proporcional al logaritmo del número de nodos del árbol.
Hash trees can be used to verify any kind of data stored, handled and transferred in and between computers. They can help ensure that data blocks received from other peers in a peer-to-peer network are received undamaged and unaltered, and even to check that the other peers do not lie and send fake blocks [REF]. proving something is or not in the tree. Merkle trees stuff.
%@book{wikipediansdata,
%title={Data Structures},
%author={Wikipedians, B.},
%url={https://books.google.es/books?id=aYxSZurAGXEC},
%publisher={PediaPress}
%}



% We store (key, values) from people in what so called Merkle trees. This allows us to ... .
%
%The following pages / This document contains the specifications of the Merkle trees implementation used in iden3 and how to generate and verify the proofs. We also add a section explaining per sobre les possibles concerns i blabla. \\

	
\section{Background}				\input{background}
%	A section introducing the problem, including definitions, references to previous work and other background details.

Problem: storage of big data structures. Store as minimum information as possible. Reference to previous work and other background details? \\

Definition of (sparse) {\bf Merkle tree}: each node consists of a pair (key, value). Our Merkle trees are binary trees % i.e. at most 2 leaves.
whose nodes consist of pairs {\bf key-value} $(k,v)$. Explain what is a pair key-value. We use them to store claims, which are kept in the leafs and the rest of the nodes furthering up are the hashes of their children. 
Trees have at most 140 levels, that is, a maximum of $2^140$ claims can be stored in them. This number is determined by the length of the hash function used, we will explain later why).\\

% IMPORTANT, MIRAR:
% http://www.diva-portal.org/smash/get/diva2:936353/FULLTEXT02.pdf
% https://eprint.iacr.org/2018/955.pdf
% https://eprint.iacr.org/2016/683.pdf

	
\section{Terminology}				% \input{terminology}
%	For consistency across documents, adopt throughout the proposal, terminology and definitions used in the ZKProof proceedings, with pointers to the relevant sections.

As we said, (sparse) Merkle trees are such and such:
% Merkle tree
\begin{itemize}
	\item {\bf Merkle tree}
	\item A {\bf Merkle audit path} for a leaf in a Merkle tree is the shortest list of additional nodes in the tree required to compute the root hash for that tree.\\
	
	If the root computed from the audit path matches the true root, then the audit path is a {\bf proof of membership} for that leaf in the tree. [SAY THAT ALSO THE NONCE AND SO ON].
	\item Sparse Merkle Tree (+ pair key-value)
\end{itemize}

Pairs key-value.
\begin{itemize}
	\item Key, value
\end{itemize}

In the tree we distinguish three different nodes (vertices):
\begin{itemize}
	\item {\bf Empty node}: A vertex that stores the value zero.
	\item {\bf Leaf}: A vertex with both empty children. Claims are stored in this kind of nodes. 
	It contains the claim {\color{blue}{i com guarda el key-value (la info que es vol guardar), amb el 1 aquell}}.
	\item {\bf Internal node}: A vertex with at least one non-empty child. It has the hash of its children. If it has one empty child, it keeps the hash of the non-empty one. %Què guarda: els hashos dels seus fills. Si el fill és empty, només es guarda el hash del no buit. 
% and then the nodes further up in the tree 
% Every time a new claim is added to the tree, it is kept in one leaf of the tree and the rest of the nodes 
% furthering up contain the hashes of their children. 
%composed of vertices of $key-value$
% that store the data in their leafs and Nodes further up in the tree are the hashes of their respective children. % All the nodes consist of a pair key-value. 
\end{itemize}

Proofs (definition of a proof The siblings stuff!!):

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.8]{images/MT-pfs-h.png} 
	%	  \includegraphics[scale=0.8]{MT-pfs.png} 
	% https://www.lucidchart.com/documents/!
\end{figure}

\begin{itemize}
	\item Proof of membership
	\item Proof of non-membership
	\begin{itemize}
		\item Case 1: empty node
		\item Case 2: different node
	\end{itemize}
\end{itemize}

%\subsubsection{Proof of membership}\input{terminology/proofs/pf-m}
%\subsubsection{Proof of non-membership}\input{terminology/proofs/pf-nm}

\section{Challenges}				%\input{challenges} 
%	For motivating the discussions, highlight the main challenges in creating such a standard, as well as any open or unresolved questions.

Improve such and such.

We included that hash(0,0)=0.

Com que no anem fins avall de tot, p.m.


% This section is not in the supposed structure of the doc.	
\section{Description}				%\input{description}

\subsection{Procedures}
\subsubsection{Storage (INSERTION) (INSERT) of entries}% in the tree}
% Storage of a claim

Let $e$ be a new entry in a tree. The node in which this piece of data is stored is uniquely determined from the data itself. The entries, claims, are arrays of four elements\footnote{{\color{blue}4 field elements of $\mathbb{F}_r$ [{\color{blue}where aquest $r$ és tal}]}}, say $e = e_0, e_1, e_2, e_3$. % consist of four values consists (is of the form) of an array of 
Then we define 
\begin{itemize}
	\item $H_{path} = H(e_2, e_3)$
	\item $H_{value} = H(e_0, e_1)$
\end{itemize}
The first value is a set of bits that is going to represent a path through the tree: starting by the less significant bit and from the root, when we go down one level, we go to the left if there is a 0 and to the right if there is a 1. {\color{blue}TODO: Posar un dibuixet d'exemple.}\\
% to the  0 goes one level down from the left and a 1 takes the right path. 
%bit takes the left child and a 1, the right one. 

Most probably\footnote{\color{blue}es basa en la probabilitat de col·lisió del hash, que és negligible, i posar referència.} we will not go down to the 140th level of the tree, that is, 
%When we want to store a claim : we take $H_{path}$. We will not go down to the 140th level, unless it is necessary. That is, 
we will not use the whole hash, only the necessary amount of bits. What we do is go down through the path until we find a node without siblings (a leaf). If the leaf is empty, we store $e$. Otherwise, that vertex stores some other claim $e'$ (as non-empty leafs store claims). This means that $H_{path}$ and $H'_{path}$ start with the same sequence of bits. What we do is that we 
% go down the tree with both claims until the first different bit and 
compare these two values and find the first different bit (included). Then we store the claims in the leafs resulting of the path up to that bit (included). 
%
This process of storing an entry $e$ in a tree $T$ with root $r$ is explained in the following pseudocode (code?).\\
%, this is the way to store a new entry $e$ in a tree $T$ with root $r$.\\
% We continue 
% and the first node without siblings, is our position. If there is a coincidence, osigui, si on hem d'anar hi ha algun node, hem de mirar la seva $H_pos$ i esplitar fins el primer número que no coincideixi. 
%until we find a node without siblings. There, we store 

%In order of lsb: $k_i = 0$ -> left, and 1 -> right. An *EXAMPLE* of a hash that would determine the position. Actually, only the necessary amount of bits! :) 

%So, in our tree there will be three types of vertices: 
% Explicar com va: hi ha tres tipus de nodes --> Buit, etc.

%In our case, these data will be claim that will consist in an array of 4 ... : $[e0, e1, e2, e3]$ and we will do $this and that for$ $H_pos$ i tal. So, Hpos is a set of bits that will represent a path through the tree.\\

% The information will be stored in leaves of the tree. \\

%, except for the leaves (although implicitly, they do). 
% A hash tree is a tree of hashes in which the leaves are hashes of data blocks in, for instance, a file or set of files.  For example, in the picture hash 0 is the result of hashing the concatenation of hash 0-0 and hash 0-1. That is, hash 0 = hash( hash 0-0 || hash 0-1 ) where || denotes concatenation. 


% \subsection{Leafs (storage of stuff)} %(claims or roots, which are also claims...))

%Each leaf of the tree stores the pair (key, value)=$(k, v)$ where $k = H_{tot}$. And the extra 1 thing, as it is *terminal* (neh?) node. 

% \subsection{Internal nodes}

%El hash és $H([\#, k_i, v_i])$, on $\# = 1$ if terminal node (leaf) and $\# = 0$ if not.

%\begin{itemize}
%	\item Hash of (left, right) -> concatenated? Mirar el Hash i tal.
%\end{itemize}



% 
% The first value $H_{pos}$ converted to binary (spec) determinates the position in which the value is stored. The second hash $H_{tot}$ is the key associated to $v$ that will be stored together with $v$.

%$$ ESCRIURE-AQUi-UN-LOOP. $$
% Arbre, l'entrada és un key value $(k,v)\in F^2$. ( p is a prime of 256 bits)

% En GoLang (Edu):
% https://github.com/iden3/go-iden3/blob/master/merkletree/merkletree.go#L260
\begin{algorithm}
	\begin{algorithmic}[1]
		\setstretch{1.2}
		\Procedure{Insert Entry $e$ in Merkle Tree $T$ with Root $r$}{}
		%
		\State $H_{path} \gets \text{GetPath($e$)}$
		\State $b \gets \text{LeastSignificantBit($H_{Index}$)}$
		%
		\If {$r$ is empty} $r \gets e$
		\Else
		\While{$r$ is internal vertex} 
		\If {$b=0$} {$r \gets \text{LeftChild($r$)}$}
		%		\EndIf
		\Else { $r \gets \text{RightChild($r$)}$} %\If{$b=1$} (alternatively)
		\EndIf
		\If {$r$ is empty}
		\State $r \gets e$
		\State $H_{Index} \gets H_{Index}\backslash{b}$
		\State $b \gets \text{LeastSignificantBit($H_{Index}$)}$
		\EndIf	
		\EndWhile
		\EndIf
		%
		\State $e' \gets \text{GetEntryStoredIn($r$)}$
		\State $H'_{path} \gets \text{GetPath($e'$)}$
		\If {$H_{path} \not= H'_{path}$}
		\State Find first bit $b_j$ such that $H_{path}(j) \not= H'_{path}(j)$
		\State Leaf($b_0...b_j$)$\gets e$ %Store $e$ in Position$(b_0...b_j)$
		\State Leaf($b_0...b'_j$)$\gets e'$ %Store $e'$ in Position$(b_0...b'_j)$
		\State RecalculateIntermediateNodeValues($T$)	
		\EndIf
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Once it is saved, then we take then we construct the leaves up the following way: el tema dels hashos, que es concatena tal i que si hi ha un zero, doncs que llavors només el hash del fill no buit. Then, the rest of intermediate nodes need to be recalculated (as they are hashes of changed children). \\

Note depth is not fixed (at the beginning, it keeps changing). Limit de l'arbre -> tants nivells com números retorna el hash (with is MiMC7, for now). \\
%The position of the (k,v) is determined by ... .
%\begin{enumerate}
%	\item First storage: we "create" a root
%	\item Then: ...
%	\item If (k,v) and k1,v1 , k2 and k1 coincide (collision resistant), but some values do so: lsb thing... .
%\end{enumerate}

% Note that the height of the tree is not fixed from the beginning. It varies when we add stuff. Nevertheless, as MiMC returns a 256-bit string, the trees are bounded to 256 levels. (REMARK that a collision of 256 has negligible probability).
% A partir de quan hi ha col·lisions?


% For a proof, give the necessary siblings. If there is no sibling --> we give a 0 back.
+ EXAMPLE.

\subsubsection{DELETE of entries}% in the tree}
+ EXAMPLE.

\subsubsection{UPDATE the tree}% in the tree}
+ EXAMPLE.

\subsection{Verification of proofs}
Given a blabla. 

\section{Security}					%\input{security}
%	If relevant, provide a proof of security in the description.


Afegir aquí que no pot lie (perquè se li requereix l'altre hash i tal). Examples if one lies.

QUE FALTA CALCULAR LA PROBABILITAT DE COL·LISIÓ.

+ Make sure we go all the tree down to a leaf (that extra 1).

Suppose the queries know the info (the claim).

We do not delete stuff.

The  security  of  an  audit  path  reduces  to  the  collision  resistance  of the underlying hash function $H$.
Proof.: %https://eprint.iacr.org/2016/683.pdf#cite.Mer%3A87%3AA, Lemma1 (page 3, sec.2.2)

\section{Implementation}			%\input{implementation}
Such implementation in GoLang and in JavaScript. \\

The entries are pairs key-value.\\

Example from iden3 documentation.
%	\subsection{Hash}				\input{implementation/mimc7}
%	\subsection{Example}			\input{implementation/example}	
	
\section {Intellectual Property}	\input{intellectual-property}

%\newpage
%\addcontentsline{toc}{section}{References}
%\bibliographystyle{acm}
%\bibliography{lit}

\end{document}